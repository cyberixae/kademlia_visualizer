<!DOCTYPE html>

<html>
    <head>
        <title>Kademlia Visualizer</title>
        
        <style>
#image {
	background-color: #eee;
	width: 600px;
	height: 600px;
}
body {
	font-family: sans-serif;
}
        </style>
        
        <script>
"use strict";

function svg_element(element_name) {
  var element = document.createElementNS("http://www.w3.org/2000/svg", element_name);
  return element;
}

function get_node(x, y, c, t) {
  var g1 = svg_element("g");
  var c1 = svg_element("circle");
  c1.setAttribute("id", "noodi-" + x);
  c1.setAttribute("cx", "0");
  c1.setAttribute("cy", "0");
  c1.setAttribute("r", "30");
  c1.setAttribute("stroke", "#000");
  c1.setAttribute("stroke-width", "2");
  c1.setAttribute("fill", c);
  g1.appendChild(c1);
  
  var t1 = svg_element("text");
  var te = document.createTextNode(t);
  t1.appendChild(te);
  t1.setAttribute("style", "text-anchor: middle;");
  t1.setAttribute("dx", "0");
  t1.setAttribute("dy", "5");
  g1.appendChild(t1);
  g1.setAttribute("transform", "translate("+x+","+y+")");
  return g1;
}

function node_locations(center, dist, nodes) {
  var i = 0;
  var center_x = center[0];
  var center_y = center[1];
  var locations = {};
  for (var id in nodes) {
    var node = nodes[id];
    var degrees = i * 2 * Math.PI / nodes.length;
    var x = center_x + dist * Math.cos(degrees);
    var y = center_y + dist * Math.sin(degrees);
    locations[node] = [x, y];
    i += 1;
  }
  return locations;
}

function draw_nodes(locations) {
  var g1 = svg_element("g");
  for (var node_id in locations) {
    var loc = locations[node_id];
    var x = loc[0];
    var y = loc[1];
    var n = get_node(x, y, '#cde', node_id);
    g1.appendChild(n);
  }
  return g1;
}

function random_id(id_length) {
  var id = '';
  for (var i = 0; i < id_length; i++) {
    id += Math.floor(Math.random() * 2)
  }
  return id;
}

function generate_nodes(id_length, amount) {
  if (amount > Math.pow(2, id_length)) {
    return [];
  }
  var ids = {};
  var unique = [];
  while (unique.length < amount) {
    var id = random_id(id_length);
    ids[id] = null;
    unique = Object.keys(ids);
  }
  return unique;
}

function line(c1, c2, stroke) {
  var x1 = c1[0];
  var y1 = c1[1];
  var x2 = c2[0];
  var y2 = c2[1];
  var l1 = svg_element("line");
  l1.setAttribute("x1", x1);
  l1.setAttribute("y1", y1);
  l1.setAttribute("x2", x2);
  l1.setAttribute("y2", y2);
  l1.setAttribute("y2", y2);
  l1.setAttribute("stroke", "#000");
  l1.setAttribute("stroke-width", stroke);
  return l1;
}

function candidate_ok(candidate, node, bucket_number) {
  if (candidate.charAt(bucket_number) == node.charAt(bucket_number)) {
    return false;
  }
  for (var i = 0; i < bucket_number; i++) {
    if (candidate.charAt(i) != node.charAt(i)) {
      return false;
    }
  }
  return true;
}

function get_bucket(nodes, bucket_size, node, bucket_number) {
  var ok = [];
  for (var i in nodes) {
    var candidate = nodes[i];
    var is_ok = candidate_ok(candidate, node, bucket_number);
    if (is_ok) {
      ok.push(candidate);
    }
  }
  while (ok.length > bucket_size) {
    var random_index = Math.floor(Math.random() * ok.length);
    ok.splice(random_index, 1);
  }

  return ok;
}

function get_buckets(nodes, bucket_size, node) {
  var buckets = [];
  var bits = node.split('');
  for (var j in bits) {
    buckets[j] = get_bucket(nodes, bucket_size, node, j);
  }
  return buckets;
}

function routing_tables(nodes, bucket_size) {
  var connections = {};
  for (var i in nodes) {
    var node = nodes[i];
    var buckets = get_buckets(nodes, bucket_size, node);
    console.log(node);
    console.log(buckets);
    connections[node] = buckets;
  }
  return connections;
}

function draw_bucket(node, targets, locations, bucket_number) {
  var g1 = svg_element("g");
  for (var i in targets) {
    var target = targets[i];
    var loc1 = locations[node]
    var loc2 = locations[target]
    //var l1 = line(loc1, loc2, 0.20 + 0.20 * (bucket_number + 1))
    var l1 = line(loc1, loc2, 1)
    g1.appendChild(l1);
  }
  return g1;
}

function draw_buckets(node, buckets, locations) {
  var g1 = svg_element("g");
  for (var bucket_number in buckets) {
    var bucket = buckets[bucket_number];
    var lines = draw_bucket(node, bucket, locations, bucket_number);
    g1.appendChild(lines);
  }
  return g1;
}

function draw_connections(connections, locations) {
  var g1 = svg_element("g");
  for (var node in connections) {
    var buckets = connections[node];
    var lines = draw_buckets(node, buckets, locations);
    g1.appendChild(lines);
  }
  return g1;
}

function get_picture(routing) {
  var center = [150, 150];
  var dist = 220;
  var g1 = svg_element("g");
  var nodes = Object.keys(routing);
  var locations = node_locations(center, dist, nodes);
  var lines = draw_connections(routing, locations);
  var nodes = draw_nodes(locations);
  g1.appendChild(lines);
  g1.appendChild(nodes);
  g1.setAttribute("transform", "translate("+center[0]+","+center[1]+")");
  return g1;
}

function get_node_count() {
  var MAX_NODES = 32;
  var element = document.getElementById('nodes');
  var node_count = element.value;
  if (node_count > MAX_NODES) {
    return MAX_NODES;
  }
  return node_count;
}

function get_bit_count(nodes) {
  var MAX_BITS = 7;
  var element = document.getElementById('bits');
  var bit_count = element.value;
  if (bit_count > MAX_BITS) {
    return MAX_BITS;
  }
  return bit_count;
}

function get_bucket_size() {
  var element = document.getElementById('bucket_size');
  var bucket_size = element.value;
  return bucket_size;
}

function refresh() {
  var container = document.getElementById("image");
  var new_svg = svg_element("svg");
  new_svg.setAttribute("id", "picture");
  new_svg.setAttribute("version", "1.2");
  new_svg.setAttribute("baseProfile", "tiny");
  
  var node_count = get_node_count();
  var bit_count = get_bit_count(node_count);
  var bucket_size = get_bucket_size();
  
  var nodes = generate_nodes(bit_count, node_count);

  var routing = routing_tables(nodes, bucket_size);

  var picture = get_picture(routing);
  new_svg.appendChild(picture);
  var old_svg = document.getElementById('picture');
  if (old_svg == null) {
    container.appendChild(new_svg);
  } else {
    container.replaceChild(new_svg, old_svg);
  }
}

window.onload = function() {
  document.getElementById('nodes').addEventListener('change', refresh, false);
  document.getElementById('bits').addEventListener('change', refresh, false);
  document.getElementById('bucket_size').addEventListener('change', refresh, false);
  refresh();
}
        </script>
 </head>
 <body>
   <h1>Kademlia Visualizer</h1>
   <p>This web app attempts to visualize topologies used by Kademlia DHT. I hope I got it right.</p>
   <table><tr>
     <td id="image"></td>
     <td><table>
         <tr><td>nodes: <input id="nodes" type="number" min="1" max="32" value="8" /></td></tr>
         <tr><td>bits: <input id="bits" type="number" min="1" max="7" value="3" /></td></tr>
         <tr><td>bucket size: <input id="bucket_size" type="number" min="0" value="16" /></td></tr>
     </table></td>
   </tr></table>
   <br />
   <hr />
   <p>
Made by <a href="http://iki.fi/toni.ruottu/">Toni Ruottu</a> in 2013.
   </p>
  </body>
</html>
